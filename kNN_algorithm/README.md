# Практична робота №3
## Завдання:
Зформулювати і запрограмувати алгоритм визначення приналежності до певного класу квітки ірис з параметрами **[5, 2.9, 1, 0.2]** методом k-NN "з нуля", тобто не використовувати готовий метод neighbors.KNeighborsClassifier(n_neighbors=3) з компоненти neighbors як в Практичній роботі № 2, а створити і реалізувати алгоритм базуючись на розумінні методу k-NN класифікації).

## Хід виконання роботи

### 1. Завантаження та підготовка даних
- Використано датасет **Iris** із бібліотеки `sklearn.datasets`.
- Датасет конвертовано у `pandas.DataFrame` для зручності роботи.
- Дані розділено на навчальну (`X_train`, `y_train`) та тестову (`X_test`, `y_test`) вибірки за допомогою `train_test_split`, при цьому **25%** даних виділено для тестування.

### 2. Реалізація алгоритму k-NN
- Створено клас `kNN`, який реалізує алгоритм **k найближчих сусідів**.
- Реалізовано наступні методи:
  - `__init__(self, k=3)`: Ініціалізація моделі з параметром `k` (кількість сусідів).
  - `euclidean_distance(self, v1, v2)`: Обчислення **евклідової відстані** між двома точками.
  - `fit(self, X_train, y_train)`: Збереження навчальних даних.
  - `get_neighbours(self, test_row)`: Визначення `k` найближчих сусідів для тестового зразка.
  - `predict(self, X_test)`: Класифікація вхідних даних за допомогою **групування найближчих сусідів** та визначення **найчастішого класу** (`mode`).
  - `accuracy(self, predictions, y_test)`: Оцінка точності класифікації.

### 3. Тренування та тестування моделі
- Створено екземпляр `knn` класу `kNN` з `k=3`.
- Виконано **навчання моделі** на `X_train`, `y_train`.
- Виконано **класифікацію тестових зразків** із `X_test`.
- Обчислено **точність моделі**, яка виводиться у відсотках.

### 4. Передбачення нового зразка
- Виконано передбачення для нового зразка `X_new = [[5, 2.9, 1, 0.2]]`.
- Отриманий клас перетворено у **назву квітки** за допомогою `iris['target_names']`.
- Виведено результат передбачення у консоль.

### 5. Виведення результатів
- Програма виводить **точність моделі** та **прогнозовану мітку нового зразка**
